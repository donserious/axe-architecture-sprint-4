[Что нужно закешировать]

Cледующим сервисам нужно настроить кэширование:

1. Shop API
2. CRM API
3. MES API

[Мотивация]
Почему внедрять кэширование?

1. Улучшение производительности: Кэширование позволяет значительно сократить время отклика API, так как данные могут
   быть
   извлечены из кэша, а не запрашиваться из базы данных. Это особенно важно для систем с высокой нагрузкой.
2. Снижение нагрузки на сервер: Кэширование уменьшает количество запросов к базе данных, что позволяет снизить нагрузку
   на
   сервер и улучшить его производительность. Это особенно актуально в условиях роста числа заказов и пользователей.
3. Увеличение масштабируемости: С помощью кэширования система может обрабатывать большее количество запросов
   одновременно,
   что позволяет легче справляться с пиковыми нагрузками.
4. Улучшение пользовательского опыта: Быстрый доступ к данным и минимальное время ожидания для пользователей повышают
   уровень удовлетворенности и лояльности клиентов.
   Проблемы, которые должно решить кэширование:
1. Долгое время отклика: Операторы и клиенты сталкиваются с медленной загрузкой страниц и задержками в получении
   информации. Кэширование может значительно ускорить доступ к часто запрашиваемым данным.
2. Увеличение числа жалоб: С ростом числа заказов и пользователей увеличивается количество жалоб на задержки и
   недоступность информации. Кэширование поможет снизить количество таких жалоб.
3. Нагрузка на базу данных: С увеличением числа запросов к базе данных может возникнуть риск перегрузки. Кэширование
   поможет распределить нагрузку и предотвратить сбои.

Элементы системы для кэширования
1. Shop API:
   Информация о товарах: Кэширование данных о ювелирных украшениях, их характеристиках и ценах.
   Каталог и категории: Кэширование структуры каталога и категорий товаров.
   Результаты поиска: Кэширование результатов поиска по товарам.
2. CRM API:
   Информация о клиентах: Кэширование данных о клиентах, их истории заказов и предпочтениях.
   Статусы заказов: Кэширование статусов заказов для быстрого доступа.
   Настройки и конфигурации: Кэширование настроек системы и конфигураций.
3. MES API:
   Результаты расчетов стоимости: Кэширование результатов расчетов стоимости для часто запрашиваемых изделий.
   Информация о заказах: Кэширование данных о текущих заказах и их статусах.
   Статистические данные: Кэширование отчетов и статистики по производственным процессам.

[Предлагаемое решение]
Почему серверное кэширование?

1. Централизованное управление: Серверное кэширование позволяет централизованно управлять кэшированными данными, что
   упрощает их обновление и инвалидацию. Это особенно важно в условиях, когда данные могут изменяться (например, статусы
   заказов или информация о товарах).
2. Снижение нагрузки на клиентские устройства: Серверное кэширование уменьшает необходимость в обработке данных на
   стороне
   клиента, что может быть критично для мобильных устройств или менее мощных компьютеров.
3. Улучшение производительности: Серверное кэширование позволяет быстро обслуживать запросы, так как данные извлекаются
   из кэша, а не запрашиваются из базы данных. Это особенно актуально для высоконагруженных систем.
4. Упрощение кэширования сложных данных: Серверное кэширование позволяет более эффективно кэшировать сложные структуры
   данных, такие как результаты расчетов стоимости или статистику, которые могут быть трудоемкими для обработки на
   клиенте.

Для серверного кэширования рекомендуется использовать паттерн Cache-Aside.
Объяснение выбора паттерна Cache-Aside:

1. Гибкость: Паттерн Cache-Aside позволяет кэшировать данные по мере необходимости. Когда приложение запрашивает данные,
   оно сначала проверяет кэш. Если данные отсутствуют, они загружаются из базы данных и помещаются в кэш. Это позволяет
   избежать ненужного кэширования редко запрашиваемых данных.
2. Контроль актуальности данных: В этом паттерне приложение отвечает за управление кэшем, что позволяет более точно
   контролировать, когда и как данные обновляются. Это особенно важно для систем, где данные могут изменяться, как в
   случае с заказами и клиентами.
3. Простота реализации: Cache-Aside проще реализовать, чем другие паттерны, такие как Write-Through, где кэширование и
   запись в базу данных происходят одновременно. Это может усложнить логику приложения и увеличить время отклика.

Почему другие паттерны не подходят:

1. Write-Through: Этот паттерн требует, чтобы все записи в кэш происходили одновременно с записью в базу данных. Это
   может привести к увеличению времени отклика, так как каждое изменение требует обновления кэша. В условиях высокой
   нагрузки это
   может стать узким местом.
2. Refresh-Ahead: Этот паттерн предполагает предзагрузку данных в кэш до их фактического запроса. Это может быть
   неэффективно, если данные не запрашиваются часто, что приведет к избыточному использованию памяти и устареванию
   данных.

[Cтратегия инвалидации кеша]

### Сравнительный анализ стратегий инвалидации кэша

| Стратегия инвалидации             | Кэш по ключу                                                                                                                   | Временная инвалидация                                                                                                         | Программная инвалидация                                                                                                                          | Write-Through                                                                                     | Refresh-Ahead                                                                                                          |
|-----------------------------------|--------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| **Лучше подходит, потому что...** | Позволяет точно контролировать, какие данные удаляются из кэша при изменении.                                                  | Простота реализации, не требует дополнительной логики для отслеживания изменений.                                             | Позволяет гибко управлять инвалидацией кэша в зависимости от бизнес-логики.                                                                      | Обеспечивает актуальность кэша, так как данные записываются одновременно в кэш и базу данных.     | Позволяет заранее загружать данные в кэш, что уменьшает время отклика.                                                 |
| **Есть особенности:**             | 1. Требует четкого определения ключей для кэшируемых данных. <br> 2. Необходима логика для удаления кэша при изменении данных. | 1. Может привести к устареванию данных, если изменения происходят часто. <br> 2. Не учитывает специфические изменения данных. | 1. Требует дополнительной логики для определения, когда и какие данные инвалидировать. <br> 2. Может быть сложно реализовать в больших системах. | 1. Увеличивает время отклика при записи данных. <br> 2. Может привести к избыточному кэшированию. | 1. Может потребовать значительных ресурсов для предзагрузки данных. <br> 2. Не всегда гарантирует актуальность данных. |
| **Позволяет сделать...**          | 1. Обеспечить актуальность данных в кэше. <br> 2. Уменьшить количество кэш-промахов.                                           | 1. Легко настроить и использовать. <br> 2. Не требует сложной логики.                                                         | 1. Гибко управлять инвалидацией в зависимости от условий. <br> 2. Позволяет инвалидировать кэш в зависимости от бизнес-правил.                   | 1. Гарантирует, что кэш всегда актуален. <br> 2. Упрощает управление данными.                     | 1. Уменьшает время отклика для часто запрашиваемых данных. <br> 2. Позволяет заранее подготовить данные.               |
| **Не позволяет сделать...**       | 1. Не всегда просто реализовать в условиях высокой нагрузки. <br> 2. Может потребовать значительных усилий для поддержки.      | 1. Не гарантирует актуальность данных. <br> 2. Может привести к частым кэш-промахам.                                          | 1. Может быть сложно поддерживать и тестировать. <br> 2. Требует дополнительных ресурсов для реализации.                                         | 1. Увеличивает сложность системы. <br> 2. Может привести к избыточному кэшированию.               | 1. Не всегда эффективно для редко запрашиваемых данных. <br> 2. Может привести к устареванию данных.                   |

### Объяснение стратегий

1. **Кэш по ключу**: Позволяет точно контролировать, какие данные удаляются из кэша при изменении. Это обеспечивает
   актуальность данных, но требует четкого определения ключей и логики для удаления кэша.

2. **Временная инвалидация**: Простая в реализации, но не гарантирует актуальность данных, что может привести к
   устареванию информации.

3. **Программная инвалидация**: Гибкая, но требует значительных усилий для реализации и поддержки, особенно в больших
   системах.

4. **Write-Through**: Обеспечивает актуальность кэша, так как данные записываются одновременно в кэш и базу данных.
   Однако это может увеличить время отклика при записи данных.

5. **Refresh-Ahead**: Позволяет заранее загружать данные в кэш, что уменьшает время отклика. Однако это может
   потребовать значительных ресурсов и не всегда гарантирует актуальность данных.

### Заключение

Почему выбрана стратегия инвалидации по ключу?

1. Актуальность данных:
   Стратегия инвалидации по ключу обеспечивает, что кэшированные данные всегда актуальны, что
   критично для системы, работающей с заказами и статусами.
2. Контроль:
   Позволяет точно контролировать, какие данные удаляются из кэша, что снижает риск устаревания информации.
3. Снижение кэш-промахов:
   Уменьшает количество кэш-промахов, так как данные обновляются по мере необходимости.


[Диаграмма последовательности действий]

[sequense_diagram.puml](sequense_diagram.puml)

